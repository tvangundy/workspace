# https://taskfile.dev

version: '3'

tasks:

  generate-tfvars:
    silent: true
    desc: "Generate terraform.tfvars from environment variables"
    vars:
      TERRAFORM_PATH: '{{env "TERRAFORM_PATH" | default "vm"}}'
    cmds:
      - |
        set -euo pipefail
        
        echo ""
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        echo "Step: Generate terraform.tfvars"
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        
        # Reload Windsor environment to get latest values (including VM_NETWORK_NAME set by initialize-context.sh)
        if command -v windsor > /dev/null 2>&1; then
          set +e  # Temporarily disable exit on error
          WINDSOR_ENV_OUTPUT=$(windsor env 2>/dev/null || echo "")
          set -e  # Re-enable exit on error
          if [ -n "${WINDSOR_ENV_OUTPUT}" ]; then
            eval "${WINDSOR_ENV_OUTPUT}" || true
          fi
        fi
        
        # Get environment variables with defaults
        INCUS_REMOTE_NAME="{{.INCUS_REMOTE_NAME}}"
        VM_NAME="{{.VM_INSTANCE_NAME}}"
        VM_NAME="${VM_NAME:-vm}"
        VM_IMAGE="{{.VM_IMAGE}}"
        VM_IMAGE="${VM_IMAGE:-ubuntu/25.04}"
        VM_MEMORY="{{.VM_MEMORY}}"
        VM_MEMORY="${VM_MEMORY:-8GB}"
        VM_CPU="{{.VM_CPU}}"
        VM_CPU="${VM_CPU:-4}"
        VM_AUTOSTART="{{.VM_AUTOSTART}}"
        VM_AUTOSTART="${VM_AUTOSTART:-false}"
        VM_DISK_SIZE="{{.VM_DISK_SIZE}}"
        # Get VM_NETWORK_NAME from environment (set by initialize-context.sh) or from Taskfile template
        PHYSICAL_NETWORK_NAME="${VM_NETWORK_NAME:-{{.VM_NETWORK_NAME}}}"
        STORAGE_POOL="{{.VM_STORAGE_POOL}}"
        STORAGE_POOL="${STORAGE_POOL:-local}"
        
        # Create terraform/<TERRAFORM_PATH> directory if it doesn't exist
        TFVARS_DIR="terraform/{{.TERRAFORM_PATH}}"
        mkdir -p "${TFVARS_DIR}"
        TFVARS_FILE="${TFVARS_DIR}/terraform.tfvars"
        
        # Generate terraform.tfvars
        {
          printf "# Generated from environment variables - do not edit manually\n"
          printf "# Update environment variables in contexts/{{.WINDSOR_CONTEXT}}/windsor.yaml instead\n"
          printf "# To regenerate, run: task vm:generate-tfvars\n"
          printf "\n"
          printf "# Incus remote configuration\n"
          printf "incus_remote_name = \"${INCUS_REMOTE_NAME}\"\n"
          printf "\n"
          printf "# VM configuration\n"
          printf "vm_name = \"${VM_NAME}\"\n"
          printf "vm_image = \"${VM_IMAGE}\"\n"
          printf "vm_memory = \"${VM_MEMORY}\"\n"
          printf "vm_cpu = \"${VM_CPU}\"\n"
          printf "vm_autostart = ${VM_AUTOSTART}\n"
          if [ -n "${VM_DISK_SIZE}" ]; then
            printf "vm_disk_size = \"${VM_DISK_SIZE}\"\n"
          else
            printf "# vm_disk_size = \"\"  # Uses storage pool default if empty\n"
          fi
          printf "\n"
          printf "# Network configuration\n"
          if [ -n "${PHYSICAL_NETWORK_NAME}" ]; then
            printf "physical_network_name = \"${PHYSICAL_NETWORK_NAME}\"\n"
          else
            printf "# physical_network_name = \"\"  # Uses default Incus network if empty\n"
          fi
          printf "\n"
          printf "# Storage configuration\n"
          printf "storage_pool = \"${STORAGE_POOL}\"\n"
        } > "${TFVARS_FILE}"
        
        echo "✅ Generated ${TFVARS_FILE} from environment variables"
        echo ""
        echo "To regenerate, run: task vm:generate-tfvars"
        echo "To modify values, update environment variables in contexts/{{.WINDSOR_CONTEXT}}/windsor.yaml"

  terraform:init:
    silent: true
    desc: "Initialize Terraform for the VM"
    vars:
      TERRAFORM_PATH: '{{env "TERRAFORM_PATH" | default "vm"}}'
    cmds:
      - |
        set -euo pipefail
        
        if [ -z "{{.WINDSOR_PROJECT_ROOT}}" ]; then
          echo "Error: WINDSOR_PROJECT_ROOT variable is not defined"
          echo "Run this from within a Windsor workspace"
          exit 1
        fi
        
        TERRAFORM_DIR="{{.WINDSOR_PROJECT_ROOT}}/terraform/{{.TERRAFORM_PATH}}"
        
        if [ ! -d "${TERRAFORM_DIR}" ]; then
          echo "Error: Terraform directory not found: ${TERRAFORM_DIR}"
          exit 1
        fi
        
        echo ""
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        echo "Step: Initialize Terraform"
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        echo ""
        cd "${TERRAFORM_DIR}"
        terraform init -upgrade

  terraform:plan:
    silent: true
    desc: "Show Terraform plan for the VM"
    vars:
      TERRAFORM_PATH: '{{env "TERRAFORM_PATH" | default "vm"}}'
    cmds:
      - task: terraform:init
      - |
        set -euo pipefail
        
        TERRAFORM_DIR="{{.WINDSOR_PROJECT_ROOT}}/terraform/{{.TERRAFORM_PATH}}"
        cd "${TERRAFORM_DIR}"
        terraform plan

  terraform:apply:
    silent: true
    desc: "Apply Terraform configuration to create VM"
    vars:
      TERRAFORM_PATH: '{{env "TERRAFORM_PATH" | default "vm"}}'
    cmds:
      - |
        set -euo pipefail
        
        TERRAFORM_DIR="{{.WINDSOR_PROJECT_ROOT}}/terraform/{{.TERRAFORM_PATH}}"
        cd "${TERRAFORM_DIR}"
        terraform apply -auto-approve

  terraform:destroy:
    silent: true
    desc: "Destroy the VM using Terraform"
    vars:
      TERRAFORM_PATH: '{{env "TERRAFORM_PATH" | default "vm"}}'
    cmds:
      - |
        set -euo pipefail
        
        TERRAFORM_DIR="{{.WINDSOR_PROJECT_ROOT}}/terraform/{{.TERRAFORM_PATH}}"
        
        if [ ! -d "${TERRAFORM_DIR}" ]; then
          echo "Error: Terraform directory not found: ${TERRAFORM_DIR}"
          exit 1
        fi
        
        # Confirm deletion
        echo "⚠️  This will destroy the Ubuntu VM and all its data"
        echo "Press Ctrl+C to cancel, or wait 5 seconds to continue..."
        sleep 5
        
        cd "${TERRAFORM_DIR}"
        terraform destroy -auto-approve
        echo "✅ VM destroyed"

  destroy:
    silent: true
    desc: "Destroy the VM using Terraform. Optionally specify VM name: task vm:destroy [-- <vm-name>]. Use TERRAFORM_PATH for runner: TERRAFORM_PATH=runner task vm:destroy -- dev-runner"
    vars:
      TERRAFORM_PATH: '{{env "TERRAFORM_PATH" | default "vm"}}'
    cmds:
      - |
        set -euo pipefail
        
        TERRAFORM_DIR="{{.WINDSOR_PROJECT_ROOT}}/terraform/{{.TERRAFORM_PATH}}"
        TFVARS_FILE="${TERRAFORM_DIR}/terraform.tfvars"
        REMOTE="{{.INCUS_REMOTE_NAME}}"
        
        if [ -z "${REMOTE}" ]; then
          echo "Error: INCUS_REMOTE_NAME variable is not defined"
          exit 1
        fi
        
        if [ ! -d "${TERRAFORM_DIR}" ]; then
          echo "Error: Terraform directory not found: ${TERRAFORM_DIR}"
          exit 1
        fi
        
        # Parse instance name from CLI args or use default
        CLI_ARGS_STR="{{.CLI_ARGS}}"
        if [ -n "${CLI_ARGS_STR}" ]; then
          eval set -- ${CLI_ARGS_STR}
          INSTANCE_NAME_ARG="${1}"
        else
          # Use default from environment variables
          if [ -n "{{.VM_INSTANCE_NAME}}" ]; then
            INSTANCE_NAME_ARG="{{.VM_INSTANCE_NAME}}"
          else
            INSTANCE_NAME_ARG="vm"
          fi
        fi
        
        echo "Destroying VM '${INSTANCE_NAME_ARG}'..."
        
        # Confirm deletion
        echo "⚠️  This will destroy the VM '${INSTANCE_NAME_ARG}' and all its data"
        echo "Press Ctrl+C to cancel, or wait 5 seconds to continue..."
        sleep 5
        
        # Check if VM exists in Incus
        VM_EXISTS=false
        if incus list "${REMOTE}:${INSTANCE_NAME_ARG}" --format csv -c n 2>/dev/null | grep -q "^${INSTANCE_NAME_ARG}$"; then
          VM_EXISTS=true
        fi
        
        # If VM exists, unregister GitHub Actions runner first (if installed)
        if [ "${VM_EXISTS}" = "true" ]; then
          RUNNER_SCRIPTS="${WINDSOR_PROJECT_ROOT:-$(pwd)}/bin/vm/scripts/runner"
          if [ -x "${RUNNER_SCRIPTS}/unregister-from-github.sh" ]; then
            REMOTE="${REMOTE}" VM_NAME="${INSTANCE_NAME_ARG}" "${RUNNER_SCRIPTS}/unregister-from-github.sh" 2>/dev/null || true
          fi
        fi
        
        # Try Terraform destroy first
        # Always use -var flag to override vm_name to ensure we destroy the correct VM
        TERRAFORM_SUCCESS=false
        cd "${TERRAFORM_DIR}"
        set +e  # Temporarily disable exit on error for Terraform
          terraform destroy -auto-approve -var "vm_name=${INSTANCE_NAME_ARG}" > /tmp/terraform_destroy.log 2>&1
        TERRAFORM_EXIT=$?
        set -e  # Re-enable exit on error
        
        # Check if Terraform actually destroyed something
        if [ ${TERRAFORM_EXIT} -eq 0 ]; then
          if grep -q "Resources: [1-9]" /tmp/terraform_destroy.log 2>/dev/null; then
            TERRAFORM_SUCCESS=true
            echo "✅ VM '${INSTANCE_NAME_ARG}' destroyed via Terraform"
          fi
        fi
        
        # If Terraform didn't destroy it (or VM wasn't in Terraform state), delete directly via Incus
        if [ "${TERRAFORM_SUCCESS}" = "false" ] && [ "${VM_EXISTS}" = "true" ]; then
          echo "⚠️  VM not found in Terraform state, deleting directly via Incus..."
          set +e  # Temporarily disable exit on error
          INCUS_DELETE_OUTPUT=$(incus delete "${REMOTE}:${INSTANCE_NAME_ARG}" --force 2>&1)
          INCUS_DELETE_EXIT=$?
          set -e  # Re-enable exit on error
          
          if [ ${INCUS_DELETE_EXIT} -eq 0 ]; then
            echo "✅ VM '${INSTANCE_NAME_ARG}' destroyed via Incus"
          else
            echo "❌ Failed to delete VM '${INSTANCE_NAME_ARG}'"
            if [ -n "${INCUS_DELETE_OUTPUT}" ]; then
              echo "   Error: ${INCUS_DELETE_OUTPUT}"
            fi
            # Try to get VM status for debugging
            echo "   VM status:"
            incus list "${REMOTE}:${INSTANCE_NAME_ARG}" 2>&1 | head -3 || true
            exit 1
          fi
        elif [ "${TERRAFORM_SUCCESS}" = "false" ] && [ "${VM_EXISTS}" = "false" ]; then
          echo "⚠️  VM '${INSTANCE_NAME_ARG}' not found in Terraform state or Incus"
          echo "   (It may have already been deleted)"
        fi

  delete:
    silent: true
    desc: "Delete the VM directly using Incus (bypasses Terraform). Optionally specify VM name: task vm:delete [-- <vm-name>]"
    cmds:
      - |
        set -euo pipefail
        
        REMOTE="{{.INCUS_REMOTE_NAME}}"
        
        if [ -z "${REMOTE}" ]; then
          echo "Error: INCUS_REMOTE_NAME variable is not defined"
          exit 1
        fi
        
        # Parse instance name from CLI args or use default
        CLI_ARGS_STR="{{.CLI_ARGS}}"
        if [ -n "${CLI_ARGS_STR}" ]; then
          eval set -- ${CLI_ARGS_STR}
          INSTANCE_NAME_ARG="${1}"
        else
          # Use default from environment variables
          if [ -n "{{.VM_INSTANCE_NAME}}" ]; then
            INSTANCE_NAME_ARG="{{.VM_INSTANCE_NAME}}"
          else
            INSTANCE_NAME_ARG="vm"
          fi
        fi
        
        echo "Deleting VM '${INSTANCE_NAME_ARG}' directly via Incus..."
        
        # Check if VM exists in Incus
        VM_EXISTS=false
        if incus list "${REMOTE}:${INSTANCE_NAME_ARG}" --format csv -c n 2>/dev/null | grep -q "^${INSTANCE_NAME_ARG}$"; then
          VM_EXISTS=true
        fi
        
        if [ "${VM_EXISTS}" = "false" ]; then
          echo "⚠️  VM '${INSTANCE_NAME_ARG}' not found on remote '${REMOTE}'"
          echo "   (It may have already been deleted)"
          exit 0
        fi
        
        # Show VM status before deletion
        echo ""
        echo "VM details:"
        incus list "${REMOTE}:${INSTANCE_NAME_ARG}" || true
        echo ""
        
        # Confirm deletion
        echo "⚠️  This will permanently delete the VM '${INSTANCE_NAME_ARG}' and all its data"
        echo "   This action cannot be undone and will NOT update Terraform state"
        echo "   Press Ctrl+C to cancel, or wait 5 seconds to continue..."
        sleep 5
        
        # Delete via Incus
        set +e  # Temporarily disable exit on error
        INCUS_DELETE_OUTPUT=$(incus delete "${REMOTE}:${INSTANCE_NAME_ARG}" --force 2>&1)
        INCUS_DELETE_EXIT=$?
        set -e  # Re-enable exit on error
        
        if [ ${INCUS_DELETE_EXIT} -eq 0 ]; then
          echo "✅ VM '${INSTANCE_NAME_ARG}' deleted successfully via Incus"
        else
          echo "❌ Failed to delete VM '${INSTANCE_NAME_ARG}'"
          if [ -n "${INCUS_DELETE_OUTPUT}" ]; then
            echo "   Error: ${INCUS_DELETE_OUTPUT}"
          fi
          # Try to get VM status for debugging
          echo "   Current VM status:"
          incus list "${REMOTE}:${INSTANCE_NAME_ARG}" 2>&1 | head -3 || true
          exit 1
        fi

  list:
    silent: true
    desc: "List all Ubuntu VMs"
    cmds:
      - |
        SCRIPT_DIR="${WINDSOR_PROJECT_ROOT:-$(pwd)}/bin/vm/scripts"
        "${SCRIPT_DIR}/list.sh"

  instantiate:
    silent: true
    desc: "Primary way to create a new Ubuntu VM. Sets up the complete VM environment including Incus client and developer tools. Use --workspace to copy/init workspace. Usage: task vm:instantiate -- <remote-name> <remote-ip> [<vm-name>] [--destroy] [--windsor-up] [--workspace] [--runner]"
    cmds:
      - task: instantiate:parse-args
      - task: instantiate:initialize-context
      - task: instantiate:verify-remote
      - task: instantiate:check-vm-image
      - task: instantiate:create-vm
      - task: instantiate:setup-ssh
      - task: instantiate:set-incus-remote-env
      - task: instantiate:setup-incus
      - task: instantiate:install-tools
      - task: instantiate:init-workspace
      - task: instantiate:validate-vm
      - task: instantiate:add-runner-if-requested
      - task: instantiate:cleanup-if-needed

  instantiate:parse-args:
    silent: true
    desc: "Parse CLI arguments for instantiate task"
    cmds:
      - |
        set -euo pipefail
        SCRIPT_DIR="${WINDSOR_PROJECT_ROOT:-$(pwd)}/bin/vm/scripts"
        # Source the script to export variables to this shell
        source "${SCRIPT_DIR}/parse-args.sh" "{{.CLI_ARGS}}"

  instantiate:install-tools:
    silent: true
    desc: "Install tools jq, Homebrew, aqua, docker, and windsor"
    cmds:
      - |
        SCRIPT_DIR="${WINDSOR_PROJECT_ROOT:-$(pwd)}/bin/vm/scripts"
        "${SCRIPT_DIR}/install-tools.sh"

  instantiate:initialize-context:
    silent: true
    desc: "Initialize Windsor context for instantiate"
    cmds:
      - |
        SCRIPT_DIR="${WINDSOR_PROJECT_ROOT:-$(pwd)}/bin/vm/scripts"
        "${SCRIPT_DIR}/initialize-context.sh"

  instantiate:verify-remote:
    silent: true
    desc: "Verify remote connection exists"
    cmds:
      - |
        SCRIPT_DIR="${WINDSOR_PROJECT_ROOT:-$(pwd)}/bin/vm/scripts"
        "${SCRIPT_DIR}/verify-remote.sh"

  instantiate:check-vm-image:
    silent: true
    desc: "Ensure VM image is available on remote"
    cmds:
      - |
        SCRIPT_DIR="${WINDSOR_PROJECT_ROOT:-$(pwd)}/bin/vm/scripts"
        "${SCRIPT_DIR}/check-vm-image.sh"

  instantiate:create-vm:
    silent: true
    desc: "Create VM using Terraform and setup developer environment"
    vars:
      TERRAFORM_PATH: '{{env "TERRAFORM_PATH" | default "vm"}}'
    cmds:
      - |
        SCRIPT_DIR="${WINDSOR_PROJECT_ROOT:-$(pwd)}/bin/vm/scripts"
        "${SCRIPT_DIR}/create-vm.sh" "{{.TERRAFORM_PATH}}"

  instantiate:setup-incus:
    silent: true
    desc: "Setup Incus client on the VM and configure remote connection"
    cmds:
      - |
        SCRIPT_DIR="${WINDSOR_PROJECT_ROOT:-$(pwd)}/bin/vm/scripts"
        "${SCRIPT_DIR}/setup-incus.sh"

  instantiate:validate-vm:
    silent: true
    desc: "Validate VM setup and functionality"
    cmds:
      - |
        SCRIPT_DIR="${WINDSOR_PROJECT_ROOT:-$(pwd)}/bin/vm/scripts"
        "${SCRIPT_DIR}/validate-vm.sh"

  instantiate:setup-ssh:
    silent: true
    desc: "Setup SSH access for the user on the VM"
    cmds:
      - |
        SCRIPT_DIR="${WINDSOR_PROJECT_ROOT:-$(pwd)}/bin/vm/scripts"
        "${SCRIPT_DIR}/setup-ssh.sh"

  instantiate:set-incus-remote-env:
    silent: true
    desc: "Set INCUS_REMOTE_NAME and INCUS_REMOTE_IP on the VM (system-wide, all users)"
    cmds:
      - |
        SCRIPT_DIR="${WINDSOR_PROJECT_ROOT:-$(pwd)}/bin/vm/scripts"
        bash "${SCRIPT_DIR}/set-incus-remote-env.sh"

  instantiate:init-workspace:
    silent: true
    desc: "Initialize workspace on the VM if VM_INIT_WORKSPACE is true"
    cmds:
      - |
        SCRIPT_DIR="${WINDSOR_PROJECT_ROOT:-$(pwd)}/bin/vm/scripts"
        "${SCRIPT_DIR}/init-workspace.sh"

  instantiate:add-runner-if-requested:
    silent: true
    desc: "If --runner was set, add GitHub Actions runner user and install runner on the VM"
    cmds:
      - |
        SCRIPT_DIR="${WINDSOR_PROJECT_ROOT:-$(pwd)}/bin/vm/scripts"
        "${SCRIPT_DIR}/add-runner-if-requested.sh"

  instantiate:cleanup-if-needed:
    silent: true
    desc: "Cleanup VM only when --destroy was set (default: keep VM)"
    cmds:
      - |
        SCRIPT_DIR="${WINDSOR_PROJECT_ROOT:-$(pwd)}/bin/vm/scripts"
        "${SCRIPT_DIR}/cleanup-if-needed.sh"

  runner:status:
    silent: true
    desc: "Check status of GitHub Actions runner. Usage: task vm:runner:status [-- <vm-instance-name>]"
    cmds:
      - |
        set -euo pipefail
        PROJECT_ROOT="${WINDSOR_PROJECT_ROOT:-$(pwd)}"
        VM_INSTANCE_NAME_ARG="{{.CLI_ARGS}}"
        VM_INSTANCE_NAME_VAL=""
        if [ -n "${VM_INSTANCE_NAME_ARG}" ]; then
          VM_INSTANCE_NAME_VAL="${VM_INSTANCE_NAME_ARG}"
        else
          # Use active Windsor context to resolve VM instance name (e.g. dev-runner from contexts/dev-runner/windsor.yaml)
          ACTIVE_CONTEXT=""
          if command -v windsor > /dev/null 2>&1; then
            ACTIVE_CONTEXT=$(windsor context get 2>/dev/null || echo "")
            [ -z "${ACTIVE_CONTEXT}" ] && [ -n "${WINDSOR_CONTEXT:-}" ] && ACTIVE_CONTEXT="${WINDSOR_CONTEXT}"
          fi
          if [ -n "${ACTIVE_CONTEXT}" ]; then
            WINDSOR_YAML="${PROJECT_ROOT}/contexts/${ACTIVE_CONTEXT}/windsor.yaml"
            if [ -f "${WINDSOR_YAML}" ]; then
              VM_INSTANCE_NAME_VAL=$(grep -E '^\s+VM_INSTANCE_NAME:' "${WINDSOR_YAML}" 2>/dev/null | head -1 | sed -E 's/.*VM_INSTANCE_NAME:[[:space:]]*["]?([^"]*)["]?.*/\1/' | tr -d ' ' || true)
              TEST_REMOTE_NAME=$(grep -E '^\s+INCUS_REMOTE_NAME:' "${WINDSOR_YAML}" 2>/dev/null | head -1 | sed -E 's/.*INCUS_REMOTE_NAME:[[:space:]]*["]?([^"]*)["]?.*/\1/' | tr -d ' ' || true)
            fi
            [ -z "${VM_INSTANCE_NAME_VAL}" ] && VM_INSTANCE_NAME_VAL="${ACTIVE_CONTEXT}"
          fi
          if [ -z "${VM_INSTANCE_NAME_VAL}" ]; then
            ENV_FILE="${PROJECT_ROOT}/.workspace/.runner-instantiate.env"
            if [ -f "${ENV_FILE}" ]; then
              VM_INSTANCE_NAME_VAL=$(grep -E '^export VM_INSTANCE_NAME=' "${ENV_FILE}" 2>/dev/null | head -1 | sed "s/^export VM_INSTANCE_NAME='\\(.*\\)'/\1/" | sed 's/^export VM_INSTANCE_NAME=//;s/^"//;s/"$//' || true)
              [ -z "${TEST_REMOTE_NAME:-}" ] && TEST_REMOTE_NAME=$(grep -E '^export TEST_REMOTE_NAME=' "${ENV_FILE}" 2>/dev/null | head -1 | sed "s/^export TEST_REMOTE_NAME='\\(.*\\)'/\1/" || true)
            fi
          fi
          VM_INSTANCE_NAME_VAL="${VM_INSTANCE_NAME_VAL:-runner}"
          TEST_REMOTE_NAME="${TEST_REMOTE_NAME:-}"
        fi
        export VM_INSTANCE_NAME="${VM_INSTANCE_NAME_VAL}"
        export VM_NAME="${VM_INSTANCE_NAME_VAL}"
        mkdir -p "${PROJECT_ROOT}/.workspace"
        ENV_FILE="${PROJECT_ROOT}/.workspace/.runner-instantiate.env"
        {
          echo "export VM_INSTANCE_NAME='${VM_INSTANCE_NAME_VAL}'"
          echo "export VM_NAME='${VM_INSTANCE_NAME_VAL}'"
          [ -n "${TEST_REMOTE_NAME:-}" ] && echo "export TEST_REMOTE_NAME='${TEST_REMOTE_NAME}'" && echo "export INCUS_REMOTE_NAME='${TEST_REMOTE_NAME}'"
        } > "${ENV_FILE}"
        SCRIPT_DIR="${PROJECT_ROOT}/bin/vm/scripts/runner"
        "${SCRIPT_DIR}/status-github-runner.sh"

  runner:help:
    silent: true
    desc: "Help for runner-related VM commands"
    cmds:
      - |
        echo "GitHub Actions Runner (via VM)"
        echo ""
        echo "Create runner VM:"
        echo "    task vm:instantiate -- <remote-name> <remote-ip> [<vm-name>] [--destroy] [--runner]"
        echo "      Set a runner context first (e.g. windsor context set dev-runner), then run with --runner."
        echo "      Examples:"
        echo "        task vm:instantiate -- nuc 192.168.2.100 dev-runner --runner"
        echo "        task vm:instantiate -- nuc 192.168.2.100 dev-runner --runner --destroy"
        echo ""
        echo "Check runner status:"
        echo "    task vm:runner:status [-- <vm-instance-name>]"
        echo "      Reports the GitHub Actions runner service status. VM instance name from CLI, active context windsor.yaml (VM_INSTANCE_NAME), or .runner-instantiate.env (default: runner)."
        echo ""
        echo "Destroy VM (including runner VMs):"
        echo "    task vm:destroy [-- <vm-name>]"
        echo "      Unregisters the runner from GitHub if present, then destroys the VM."
        echo ""

  help:
    silent: true
    desc: "Ubuntu VM commands"
    cmds:
      - |
        echo "Ubuntu Virtual Machine (Incus)"
        echo ""
        echo "Create VM:"
        echo "    task vm:instantiate -- <remote-name> <remote-ip> [<vm-name>] [--destroy] [--windsor-up] [--workspace] [--runner]"
        echo "      Primary way to create and setup a new VM (includes Incus client setup)"
        echo "      Arguments:"
        echo "        <remote-name>          Required: Name of the Incus remote"
        echo "        <remote-ip>            Required: IP address of the Incus remote (set on VM as INCUS_REMOTE_IP)"
        echo "        <vm-name>              Optional: Name for the VM (default: 'vm')"
        echo "      Options:"
        echo "        --destroy               Destroy VM at end of instantiate (default: keep VM)"
        echo "        --windsor-up            Run windsor init and windsor up after workspace setup"
        echo "        --workspace             Copy and initialize workspace on the VM (default: skip)"
        echo "        --runner                Add a GitHub Actions runner to the VM at the end (setup-runner-user + install-github-runner)"
        echo "      Examples:"
        echo "        task vm:instantiate -- nuc 192.168.2.100"
        echo "        task vm:instantiate -- nuc 192.168.2.100 my-vm"
        echo "        task vm:instantiate -- nuc 192.168.2.100 my-vm --destroy"
        echo "        task vm:instantiate -- nuc 192.168.2.100 my-vm --workspace"
        echo "        task vm:instantiate -- nuc 192.168.2.100 my-vm --runner"
        echo ""
        echo "List VMs:"
        echo "    task vm:list"
        echo "      Lists all Ubuntu VMs on the configured remote."
        echo ""
        echo "Delete VM (direct Incus):"
        echo "    task vm:delete [-- <vm-name>]"
        echo "      Deletes the VM directly via Incus (bypasses Terraform)."
        echo "      If <vm-name> is not provided, uses the current context."
        echo ""
        echo "Destroy VM (Terraform):"
        echo "    task vm:destroy [-- <vm-name>]"
        echo "      Destroys the VM using Terraform (updates Terraform state)."
        echo "      For runner VMs, unregisters from GitHub first. Falls back to Incus delete if not in Terraform state."
        echo ""
        echo "Runner status:"
        echo "    task vm:runner:status [-- <runner-name>]"
        echo "      Check GitHub Actions runner service status. See task vm:runner:help for more."
        echo ""

