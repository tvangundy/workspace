# https://taskfile.dev

version: '3'

tasks:
  test:
    silent: true
    desc: Test VM setup by running through all runbook steps and validating the VM. Use --keep to leave VM running after test.
    cmds:
      - |
        set -euo pipefail
        
        # Parse CLI args
        CLI_ARGS_STR="{{.CLI_ARGS}}"
        if [ -z "${CLI_ARGS_STR}" ]; then
          echo "Error: INCUS_REMOTE_NAME is required"
          echo "Usage: task vm-test:test -- <incus-remote-name> [--keep]"
          exit 1
        fi
        
        # Parse arguments
        eval set -- ${CLI_ARGS_STR}
        TEST_REMOTE_NAME="${1}"
        shift || true
        
        # Check for flags
        SKIP_CLEANUP=false
        while [ $# -gt 0 ]; do
          case "${1}" in
            --keep|--no-cleanup)
              SKIP_CLEANUP=true
              shift
              ;;
            *)
              echo "‚ö†Ô∏è  Warning: Unknown argument '${1}', ignoring"
              shift
              ;;
          esac
        done
        
        # Get and export PROJECT_ROOT
        PROJECT_ROOT="{{.WINDSOR_PROJECT_ROOT}}"
        if [ -z "${PROJECT_ROOT}" ]; then
          PROJECT_ROOT="$(pwd)"
        fi
        
        # Set VM_INSTANCE_NAME explicitly to ensure it's "vm-test" for the test
        export VM_INSTANCE_NAME="${VM_INSTANCE_NAME:-vm-test}"
        export VM_NAME="${VM_NAME:-vm-test}"  # Ensure VM_NAME is also set
        
        # Export for use in run and all its subtasks
        export TEST_REMOTE_NAME="${TEST_REMOTE_NAME}"
        export SKIP_CLEANUP="${SKIP_CLEANUP}"
        export PROJECT_ROOT="${PROJECT_ROOT}"
        export TESTS_PASSED=0
        export TESTS_FAILED=0
        export FAILED_TESTS=""
        
        task vm-test:run

  run:
    silent: true
    desc: Main VM test orchestrator - runs all test steps in sequence
    cmds:
      - task: initialize-context
      - task: verify-remote
      - task: check-existing-vm
      - task: generate-tfvars-step
      - task: check-vm-image
      - task: terraform-init-step
      - task: create-vm
      - task: wait-for-vm
      - task: get-vm-ip
      - task: setup-developer-env
      - task: validate-vm-setup
      - task: final-summary

  initialize-context:
    silent: true
    desc: Initialize Windsor context and create windsor.yaml
    cmds:
      - |
        set -euo pipefail
        
        # Get VM configuration from environment or use defaults
        VM_NAME="{{.VM_INSTANCE_NAME}}"
        VM_NAME="${VM_NAME:-vm-test}"
        VM_IMAGE="{{.VM_IMAGE}}"
        VM_IMAGE="${VM_IMAGE:-ubuntu/24.04}"
        VM_MEMORY="{{.VM_MEMORY}}"
        VM_MEMORY="${VM_MEMORY:-16GB}"
        VM_CPU="{{.VM_CPU}}"
        VM_CPU="${VM_CPU:-4}"
        VM_DISK_SIZE="{{.VM_DISK_SIZE}}"
        VM_DISK_SIZE="${VM_DISK_SIZE:-100GB}"
        VM_NETWORK_NAME="${VM_NETWORK_NAME:-}"
        VM_STORAGE_POOL="${VM_STORAGE_POOL:-local}"
        VM_AUTOSTART="${VM_AUTOSTART:-false}"
        VM_INIT_WORKSPACE="${VM_INIT_WORKSPACE:-true}"
        DOCKER_HOST="${DOCKER_HOST:-unix:///var/run/docker.sock}"
        
        # Get project root
        PROJECT_ROOT="{{.WINDSOR_PROJECT_ROOT}}"
        if [ -z "${PROJECT_ROOT}" ]; then
          PROJECT_ROOT="$(pwd)"
        fi
        
        echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
        echo "Ubuntu VM Setup Test"
        echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
        echo ""
        echo "Remote: ${TEST_REMOTE_NAME}"
        echo "VM Name: ${VM_NAME}"
        echo ""
        
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        echo "Step 0: Initialize Windsor Context"
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        
        # Create contexts directory if it doesn't exist
        CONTEXTS_DIR="${PROJECT_ROOT}/contexts"
        TEST_CONTEXT_DIR="${CONTEXTS_DIR}/${VM_NAME}"
        TEST_WINDSOR_YAML="${TEST_CONTEXT_DIR}/windsor.yaml"
        
        mkdir -p "${TEST_CONTEXT_DIR}"
        
        # Auto-detect physical network if not set
        if [ -z "${VM_NETWORK_NAME}" ]; then
          set +e
          # Try common physical network interface names
          for NET_IFACE in eno1 enp5s0 enp0s3 eth0; do
            if incus network show "${TEST_REMOTE_NAME}:${NET_IFACE}" >/dev/null 2>&1; then
              VM_NETWORK_NAME="${NET_IFACE}"
              echo "  Detected physical network '${NET_IFACE}', using it for direct network attachment"
              break
            fi
          done
          set -e
          
          # If no physical network found, warn that VM will use bridge network
          if [ -z "${VM_NETWORK_NAME}" ]; then
            echo "  ‚ö†Ô∏è  No physical network interface detected, VM will use default Incus bridge network"
            echo "     This means the VM will get an IP on the Incus bridge (10.x.x.x) instead of your local network"
            echo "     To fix: Set VM_NETWORK_NAME in contexts/${VM_NAME}/windsor.yaml to your physical interface name (e.g., eno1, enp5s0)"
          fi
        fi
        
        # Create or update windsor.yaml
        {
          echo "id: ${VM_NAME}-VM"
          echo "provider: generic"
          echo "environment:"
          echo "  # Use remote Incus server"
          echo "  INCUS_REMOTE_NAME: ${TEST_REMOTE_NAME}"
          echo ""
          echo "  # Workspace initialization"
          echo "  VM_INIT_WORKSPACE: ${VM_INIT_WORKSPACE}"
          echo ""
          echo "  # Default VM name"
          echo "  VM_INSTANCE_NAME: ${VM_NAME}"
          echo ""
          echo "  # Default image"
          echo "  VM_IMAGE: ${VM_IMAGE}"
          echo ""
          echo "  # VM resources"
          echo "  VM_MEMORY: ${VM_MEMORY}"
          echo "  VM_CPU: ${VM_CPU}"
          echo "  VM_DISK_SIZE: ${VM_DISK_SIZE}"
          echo ""
          echo "  # Network interface for VM"
          if [ -n "${VM_NETWORK_NAME}" ]; then
            echo "  VM_NETWORK_NAME: ${VM_NETWORK_NAME}"
          else
            echo "  # VM_NETWORK_NAME: \"\"  # Uses default Incus network if empty"
          fi
          echo ""
          echo "  # Storage pool"
          echo "  VM_STORAGE_POOL: ${VM_STORAGE_POOL}"
          echo ""
          echo "  # Auto-start VM on host boot"
          echo "  VM_AUTOSTART: ${VM_AUTOSTART}"
          echo ""
          echo "  # Use default Docker socket"
          echo "  DOCKER_HOST: ${DOCKER_HOST}"
        } > "${TEST_WINDSOR_YAML}"
        
        echo "‚úÖ Created/updated ${TEST_WINDSOR_YAML}"
        
        # Set Windsor context
        if command -v windsor > /dev/null 2>&1; then
          if windsor context set "${VM_NAME}" > /dev/null 2>&1; then
            echo "‚úÖ Set Windsor context to '${VM_NAME}'"
          else
            if windsor init --context "${VM_NAME}" --backend local --config-dir "${TEST_CONTEXT_DIR}" > /dev/null 2>&1; then
              echo "‚úÖ Initialized and set Windsor context to '${VM_NAME}'"
            else
              echo "‚ö†Ô∏è  Warning: Could not set Windsor context, but continuing"
            fi
          fi
        fi
        
        # Export variables for subsequent tasks
        export VM_NAME="${VM_NAME}"
        export VM_INSTANCE_NAME="${VM_NAME}"  # Ensure VM_INSTANCE_NAME is set for vm:generate-tfvars
        export VM_NETWORK_NAME="${VM_NETWORK_NAME:-}"  # Export network name for terraform.tfvars generation
        export WINDSOR_CONTEXT="${VM_NAME}"
        export WINDSOR_PROJECT_ROOT="${PROJECT_ROOT}"
        export PROJECT_ROOT="${PROJECT_ROOT}"
        export TEST_CONTEXT_DIR="${TEST_CONTEXT_DIR}"
        export TEST_WINDSOR_YAML="${TEST_WINDSOR_YAML}"

  verify-remote:
    silent: true
    desc: Verify Incus remote connection
    cmds:
      - |
        set -euo pipefail
        
        echo ""
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        echo "Step 1: Verify Remote Connection"
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        
        set +e
        REMOTE_EXISTS=false
        if incus remote list --format csv 2>/dev/null | grep -q "^${TEST_REMOTE_NAME},"; then
          REMOTE_EXISTS=true
        elif incus remote list 2>/dev/null | grep -q "${TEST_REMOTE_NAME}"; then
          REMOTE_EXISTS=true
        fi
        set -e
        
        if [ "${REMOTE_EXISTS}" = "true" ]; then
          echo "‚úÖ Remote '${TEST_REMOTE_NAME}' exists"
        else
          echo "‚ùå FAIL: Remote '${TEST_REMOTE_NAME}' does not exist"
          echo ""
          echo "Available remotes:"
          incus remote list 2>/dev/null || echo "  (No remotes configured)"
          exit 1
        fi
        
        set +e
        if incus list "${TEST_REMOTE_NAME}:" --format csv > /dev/null 2>&1; then
          echo "‚úÖ Can connect to remote '${TEST_REMOTE_NAME}'"
          set -e
        else
          echo "‚ùå FAIL: Cannot connect to remote '${TEST_REMOTE_NAME}'"
          exit 1
        fi

  check-existing-vm:
    silent: true
    desc: Check if VM already exists and error if it does
    cmds:
      - |
        set -euo pipefail
        
        VM_NAME="${VM_NAME:-vm-test}"
        
        if incus list "${TEST_REMOTE_NAME}:${VM_NAME}" --format csv -c n 2>/dev/null | grep -q "^${VM_NAME}$"; then
          echo ""
          echo "‚ùå ERROR: VM '${VM_NAME}' already exists on remote '${TEST_REMOTE_NAME}'."
          echo ""
          echo "   To continue, you must first destroy the existing VM."
          echo "   You can call the destroy task by VM name:"
          echo "     task vm:destroy -- ${VM_NAME}"
          echo ""
          echo "   Or set the Windsor context and destroy:"
          echo "     windsor context set ${VM_NAME}"
          echo "     task vm:destroy"
          echo ""
          exit 1
        fi

  generate-tfvars-step:
    silent: true
    desc: Generate terraform.tfvars file
    cmds:
      - |
        set -euo pipefail
        
        echo ""
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        echo "Test: Generate terraform.tfvars"
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        
        # Ensure environment variables are loaded from Windsor
        VM_NAME="${VM_NAME:-vm-test}"
        VM_INSTANCE_NAME="${VM_INSTANCE_NAME:-${VM_NAME}}"  # Use VM_NAME as fallback
        VM_NETWORK_NAME="${VM_NETWORK_NAME:-}"  # Get from environment (set by initialize-context)
        WINDSOR_PROJECT_ROOT="${WINDSOR_PROJECT_ROOT:-$(pwd)}"
        
        # Try to load from Windsor if available
        if command -v windsor > /dev/null 2>&1; then
          set +e
          WINDSOR_ENV_OUTPUT=$(windsor env 2>/dev/null || echo "")
          set -e
          if [ -n "${WINDSOR_ENV_OUTPUT}" ]; then
            eval "${WINDSOR_ENV_OUTPUT}" || true
            # Re-evaluate VM_INSTANCE_NAME after loading Windsor env
            VM_INSTANCE_NAME="${VM_INSTANCE_NAME:-${VM_NAME}}"
            # Re-evaluate VM_NETWORK_NAME after loading Windsor env
            VM_NETWORK_NAME="${VM_NETWORK_NAME:-}"
          fi
        fi
        
        # Ensure VM_INSTANCE_NAME matches VM_NAME (should be "vm-test")
        if [ -z "${VM_INSTANCE_NAME}" ] || [ "${VM_INSTANCE_NAME}" = "vm" ]; then
          VM_INSTANCE_NAME="${VM_NAME}"
        fi
        
        # Derive WINDSOR_CONTEXT from VM_NAME if not set
        WINDSOR_CONTEXT="${WINDSOR_CONTEXT:-${VM_NAME}}"
        
        # Ensure critical variables are exported for Taskfile template evaluation
        export WINDSOR_CONTEXT="${WINDSOR_CONTEXT}"
        export VM_NAME="${VM_NAME}"
        export VM_INSTANCE_NAME="${VM_INSTANCE_NAME}"  # Explicitly export VM_INSTANCE_NAME
        export VM_NETWORK_NAME="${VM_NETWORK_NAME}"  # Export VM_NETWORK_NAME for terraform.tfvars
        export WINDSOR_PROJECT_ROOT="${WINDSOR_PROJECT_ROOT}"
        export INCUS_REMOTE_NAME="${INCUS_REMOTE_NAME:-${TEST_REMOTE_NAME}}"
        
        # Debug: Verify variables are set
        echo "üîç Environment variables for Taskfile:"
        echo "   WINDSOR_CONTEXT: ${WINDSOR_CONTEXT}"
        echo "   VM_NAME: ${VM_NAME}"
        echo "   VM_INSTANCE_NAME: ${VM_INSTANCE_NAME}"
        echo "   VM_NETWORK_NAME: ${VM_NETWORK_NAME:-(not set, will use default Incus network)}"
        echo "   WINDSOR_PROJECT_ROOT: ${WINDSOR_PROJECT_ROOT}"
        echo "   INCUS_REMOTE_NAME: ${INCUS_REMOTE_NAME}"
        
        # Pass environment variables explicitly to task command
        env WINDSOR_CONTEXT="${WINDSOR_CONTEXT}" \
            VM_NAME="${VM_NAME}" \
            VM_INSTANCE_NAME="${VM_INSTANCE_NAME}" \
            VM_NETWORK_NAME="${VM_NETWORK_NAME}" \
            WINDSOR_PROJECT_ROOT="${WINDSOR_PROJECT_ROOT}" \
            INCUS_REMOTE_NAME="${INCUS_REMOTE_NAME}" \
            task vm:generate-tfvars > /tmp/test_output.log 2>&1
        
        if [ $? -eq 0 ]; then
          echo "‚úÖ PASS: Generate terraform.tfvars"
        else
          echo "‚ùå FAIL: Generate terraform.tfvars"
          cat /tmp/test_output.log
          exit 1
        fi
        
        if [ -f terraform/vm/terraform.tfvars ]; then
          echo "‚úÖ PASS: terraform.tfvars file exists"
        else
          echo "‚ùå FAIL: terraform.tfvars file does not exist"
          exit 1
        fi

  check-vm-image:
    silent: true
    desc: Ensure VM image is available
    cmds:
      - |
        set -euo pipefail
        
        echo ""
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        echo "Step 3: Ensure VM Image is Available"
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        
        VM_IMAGE="${VM_IMAGE:-ubuntu/24.04}"
        
        set +e
        IMAGE_EXISTS=false
        if incus image alias list "${TEST_REMOTE_NAME}:" --format csv 2>/dev/null | grep -q "^${VM_IMAGE},"; then
          # Check if it's a VM image
          IMG_FP=$(incus image alias list "${TEST_REMOTE_NAME}:" --format csv 2>/dev/null | grep "^${VM_IMAGE}," | cut -d',' -f2 | head -1)
          if [ -n "${IMG_FP}" ]; then
            IMG_INFO=$(incus image info "${TEST_REMOTE_NAME}:${IMG_FP}" 2>/dev/null || echo "")
            if echo "${IMG_INFO}" | grep -q "Type:.*virtual-machine"; then
              IMAGE_EXISTS=true
              echo "‚úÖ VM image '${VM_IMAGE}' already exists on remote '${TEST_REMOTE_NAME}'"
            fi
          fi
        fi
        set -e
        
        if [ "${IMAGE_EXISTS}" = "false" ]; then
          echo "‚ö†Ô∏è  VM image '${VM_IMAGE}' not found on remote '${TEST_REMOTE_NAME}'"
          echo "   Continuing test (image import will be tested during VM creation)"
        fi

  terraform-init-step:
    silent: false
    desc: Initialize Terraform
    cmds:
      - |
        set -euo pipefail
        
        echo ""
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        echo "Test: Terraform initialization"
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        echo ""
        echo "‚ÑπÔ∏è  Initializing Terraform (this may take a moment to download providers)..."
        echo ""
        
        if task vm:terraform:init; then
          echo ""
          echo "‚úÖ PASS: Terraform initialization"
        else
          echo ""
          echo "‚ùå FAIL: Terraform initialization"
          exit 1
        fi

  create-vm:
    silent: true
    desc: Create VM using Terraform
    cmds:
      - |
        set -euo pipefail
        
        echo ""
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        echo "Creating VM (this may take a few minutes)..."
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        
        task vm:generate-tfvars > /dev/null 2>&1
        task vm:terraform:init > /dev/null 2>&1
        
        if task vm:terraform:apply > /tmp/terraform_apply.log 2>&1; then
          echo "‚úÖ VM created successfully"
        else
          echo "‚ùå FAIL: VM creation failed"
          cat /tmp/terraform_apply.log | tail -50
          exit 1
        fi

  wait-for-vm:
    silent: true
    desc: Wait for VM to boot and become ready
    cmds:
      - |
        set -euo pipefail
        
        echo ""
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        echo "Waiting for VM to be ready..."
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        
        VM_NAME="${VM_NAME:-vm-test}"
        MAX_WAIT=120
        ELAPSED=0
        
        while [ ${ELAPSED} -lt ${MAX_WAIT} ]; do
          if incus exec "${TEST_REMOTE_NAME}:${VM_NAME}" -- true 2>/dev/null; then
            echo "‚úÖ VM agent is ready"
            break
          fi
          sleep 5
          ELAPSED=$((ELAPSED + 5))
          echo "  Waiting... (${ELAPSED}s/${MAX_WAIT}s)"
        done
        
        if [ ${ELAPSED} -ge ${MAX_WAIT} ]; then
          echo "‚ùå FAIL: VM agent not ready after ${MAX_WAIT} seconds"
          exit 1
        fi

  get-vm-ip:
    silent: true
    desc: Get VM IP address
    cmds:
      - |
        set -euo pipefail
        
        echo ""
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        echo "Test: VM has IP address"
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        
        VM_NAME="${VM_NAME:-vm-test}"
        VM_IP=""
        VM_NETWORK_NAME="${VM_NETWORK_NAME:-}"
        
        # Wait for IP to be assigned (DHCP may take a moment)
        echo "  Waiting for VM to get IP address from DHCP..."
        MAX_WAIT=60
        ELAPSED=0
        set +e
        
        while [ ${ELAPSED} -lt ${MAX_WAIT} ]; do
          VM_IP=""
          
          # Method 1: Try hostname -I (gets all IPs, filter out loopback)
          if [ -z "${VM_IP}" ]; then
            VM_IP=$(incus exec "${TEST_REMOTE_NAME}:${VM_NAME}" -- \
              hostname -I 2>/dev/null | awk '{for(i=1;i<=NF;i++) if($i !~ /^127\.|^172\.17\.|^10\.53\.68\./) {print $i; exit}}' || echo "")
          fi
          
          # Method 2: Try eth0 interface
          if [ -z "${VM_IP}" ]; then
            VM_IP=$(incus exec "${TEST_REMOTE_NAME}:${VM_NAME}" -- \
              ip -4 addr show eth0 2>/dev/null | grep -oE 'inet [0-9.]+' | awk '{print $2}' | head -n 1 2>/dev/null || echo "")
          fi
          
          # Method 3: Try all interfaces (ip addr show)
          if [ -z "${VM_IP}" ]; then
            VM_IP=$(incus exec "${TEST_REMOTE_NAME}:${VM_NAME}" -- \
              ip -4 addr show 2>/dev/null | grep -oE 'inet [0-9.]+' | awk '{print $2}' | \
              grep -vE '^127\.|^172\.17\.|^10\.53\.68\.' | head -n 1 || echo "")
          fi
          
          # Method 4: Get from incus list JSON format
          if [ -z "${VM_IP}" ]; then
            # Try to parse JSON from incus list
            ALL_IPS=$(incus list "${TEST_REMOTE_NAME}:${VM_NAME}" --format json 2>/dev/null | \
              grep -oE '"IPv4":"[0-9.]+' | cut -d'"' -f4 || echo "")
            
            # If using physical network, prefer IP not on bridge
            if [ -n "${VM_NETWORK_NAME}" ] && [ "${VM_NETWORK_NAME}" != "incusbr0" ]; then
              VM_IP=$(echo "${ALL_IPS}" | grep -vE '^172\.17\.|^10\.53\.68\.' | head -n 1 || echo "")
            fi
            
            # If still no IP, use first available
            if [ -z "${VM_IP}" ]; then
              VM_IP=$(echo "${ALL_IPS}" | head -n 1 || echo "")
            fi
          fi
          
          # Check if we have a valid IP
          if [ -n "${VM_IP}" ] && echo "${VM_IP}" | grep -qE '^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$'; then
            break
          fi
          
          sleep 5
          ELAPSED=$((ELAPSED + 5))
          printf "\r  Waiting... (${ELAPSED}s/${MAX_WAIT}s)"
        done
        echo ""
        
        set -e
        
        # Validate IP address
        if [ -n "${VM_IP}" ] && echo "${VM_IP}" | grep -qE '^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$'; then
          echo "‚úÖ PASS: VM has IP address (${VM_IP})"
          export VM_IP="${VM_IP}"
        else
          echo "‚ùå FAIL: VM does not have a valid IP address after ${MAX_WAIT} seconds"
          echo ""
          echo "   Debug information:"
          echo "   - VM status:"
          incus list "${TEST_REMOTE_NAME}:${VM_NAME}" --format csv -c ns 2>/dev/null || echo "     (could not get status)"
          echo "   - Network interfaces:"
          incus exec "${TEST_REMOTE_NAME}:${VM_NAME}" -- ip addr show 2>/dev/null | head -20 || echo "     (could not get interfaces)"
          echo "   - incus list output:"
          incus list "${TEST_REMOTE_NAME}:${VM_NAME}" --format json 2>/dev/null | head -20 || echo "     (could not get list output)"
          exit 1
        fi

  setup-developer-env:
    silent: true
    desc: Setup developer environment in VM
    cmds:
      - |
        set -euo pipefail
        
        # Skip if local remote
        if [ "${TEST_REMOTE_NAME}" = "local" ]; then
          echo ""
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "Skipping developer environment setup (local remote)"
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          exit 0
        fi
        
        echo ""
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        echo "Setting up developer environment..."
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        echo "  This may take 5-10 minutes (installing packages, Docker, etc.)"
        echo "  Progress will be logged to /tmp/setup_env.log"
        
        VM_NAME="${VM_NAME:-vm-test}"
        
        # Run setup-env with timeout (15 minutes max)
        SETUP_TIMEOUT=900
        set +e
        
        TIMEOUT_CMD=""
        if command -v timeout > /dev/null 2>&1; then
          TIMEOUT_CMD="timeout"
        elif command -v gtimeout > /dev/null 2>&1; then
          TIMEOUT_CMD="gtimeout"
        fi
        
        if [ -n "${TIMEOUT_CMD}" ]; then
          if ${TIMEOUT_CMD} ${SETUP_TIMEOUT} task vm:create:setup-env -- ${VM_NAME} > /tmp/setup_env.log 2>&1; then
            echo "‚úÖ Developer environment setup completed"
          else
            echo "‚ùå FAIL: Developer environment setup failed"
            cat /tmp/setup_env.log | tail -50
            exit 1
          fi
        else
          # Fallback: run without timeout
          if task vm:create:setup-env -- ${VM_NAME} > /tmp/setup_env.log 2>&1; then
            echo "‚úÖ Developer environment setup completed"
          else
            echo "‚ùå FAIL: Developer environment setup failed"
            cat /tmp/setup_env.log | tail -50
            exit 1
          fi
        fi
        
        set -e

  validate-vm-setup:
    silent: true
    desc: Validate VM setup (git, docker, SSH, user, etc.)
    cmds:
      - |
        set -euo pipefail
        
        echo ""
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        echo "Step 9: Validate VM Setup"
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        
        VM_NAME="${VM_NAME:-vm-test}"
        CURRENT_USER=$(whoami)
        
        # Test function
        test_step() {
          local test_name="$1"
          local test_command="$2"
          
          echo ""
          echo "Test: ${test_name}"
          if eval "${test_command}" > /tmp/test_output.log 2>&1; then
            echo "‚úÖ PASS: ${test_name}"
            return 0
          else
            echo "‚ùå FAIL: ${test_name}"
            cat /tmp/test_output.log | tail -20
            return 1
          fi
        }
        
        # Validate developer tools
        test_step "Git is installed" \
          "incus exec ${TEST_REMOTE_NAME}:${VM_NAME} -- git --version"
        
        test_step "Docker is installed" \
          "incus exec ${TEST_REMOTE_NAME}:${VM_NAME} -- docker --version"
        
        test_step "Docker service is running" \
          "incus exec ${TEST_REMOTE_NAME}:${VM_NAME} -- systemctl is-active --quiet docker"
        
        test_step "SSH service is running" \
          "incus exec ${TEST_REMOTE_NAME}:${VM_NAME} -- systemctl is-active --quiet ssh"
        
        test_step "User account matches host" \
          "incus exec ${TEST_REMOTE_NAME}:${VM_NAME} -- whoami | grep -q '^${CURRENT_USER}$'"
        
        test_step "Git is configured" \
          "incus exec ${TEST_REMOTE_NAME}:${VM_NAME} -- git config --global user.name | grep -q ."
        
        test_step "SSH keys are set up" \
          "incus exec ${TEST_REMOTE_NAME}:${VM_NAME} -- test -f ~/.ssh/id_rsa || test -f ~/.ssh/id_ed25519"
        
        echo ""
        echo "‚úÖ All VM setup validations passed"

  final-summary:
    silent: true
    desc: Display final test summary and cleanup if needed
    cmds:
      - |
        set -euo pipefail
        
        echo ""
        echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
        echo "Test Summary"
        echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
        echo "‚úÖ ALL TESTS PASSED"
        echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
        
        if [ "${SKIP_CLEANUP}" = "true" ]; then
          echo ""
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "Skipping cleanup (--keep flag set)"
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          VM_NAME="${VM_NAME:-vm-test}"
          echo "VM '${VM_NAME}' on remote '${TEST_REMOTE_NAME}' has been left running."
        else
          task vm-test:clean
        fi

  clean:
    silent: true
    desc: Clean up test VM - destroy VM and remove config files
    cmds:
      - |
        set -euo pipefail
        
        # Calculate paths if not already set
        if [ -z "${PROJECT_ROOT:-}" ]; then
          PROJECT_ROOT="{{.WINDSOR_PROJECT_ROOT}}"
          if [ -z "${PROJECT_ROOT}" ] || [ "${PROJECT_ROOT}" = "{{.WINDSOR_PROJECT_ROOT}}" ]; then
            PROJECT_ROOT="$(pwd)"
          fi
        fi
        
        VM_NAME="${VM_NAME:-vm-test}"
        
        echo ""
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        echo "Cleaning up test VM..."
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        
        if task vm:terraform:destroy > /tmp/cleanup.log 2>&1; then
          echo "‚úÖ Test VM deleted successfully"
        else
          echo "‚ö†Ô∏è  Warning: Failed to delete test VM. Manual cleanup may be required."
          cat /tmp/cleanup.log | tail -10
        fi

